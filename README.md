# vision
简易的浏览器端Excel

> `vite + vuejs3.x`

## 单元格渲染
使用渲染函数（h）自定义渲染，未编辑时都是静态渲染，点击某一个才将编辑相关的组件渲染到对应位置


## 单元格编辑

| 优缺点 | vue 框架渲染 | 半框架 + 半原生 |
| ---- | ---- | ---- |
| 好处 | 1、方便。  <br>2、数据驱动 | 1、初次渲染使用 `vue` 框架渲染  <br>1、使用代理的方式，将事件绑定在上级；触发的时候再找到相应的单元格。 <br>2、点击编辑时可以快速定位标记到单元格，几乎无延迟  <br>3、数据更新使用 `vnode + createApp` 直接更新，效率高
| 问题 | 1、数量多的时候，渲染速度慢。  <br>2、事件绑定多的时候，响应速度慢 | 框架与原生的结合，需要对原生事件进行处理，才能获得想要的结果


## 结构

### 表头
固定表头、固定列使用粘性定位 `position: sticky;`


### 表格内容
固定列使用粘性定位 `position: sticky;`，将固定的列、非固定的列分开渲染

## 实现

### 列配置

包含
- keyCode: string; // 数据源中显示的字段对应的属性名
- label: string; // 名称
- valueType: ColumnItemType; // 组件类型，在新增列时确定
- align?: 'left' | 'center' | 'right',
- fixed?: boolean; // 固定列
- hidden?: boolean; // 不显示
- readonly?: boolean; // 只读
- required?: boolean; // 必填
- width?: number; // 自定义列宽度
- render?: (h: CreateElement, item: any) => VNode | string;

### 源数据
对象数组，格式无要求，但是要个列配置的 `keyCode` 对应上

## 总结
简单的方案可以使用纯框架实现，但是数据行数多，列数也多的情况下，纯框架方案因为数据驱动有各种绑定关系，一个更新导致一连串的更新，使得数据更新的时候，视图渲染有延迟

基于性能、体验的考虑：
1. 初次渲染采用框架渲染
2. 更新使用原生方式手动更新
